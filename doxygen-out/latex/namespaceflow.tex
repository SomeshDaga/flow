\hypertarget{namespaceflow}{}\doxysection{flow Namespace Reference}
\label{namespaceflow}\index{flow@{flow}}


Flow input synchronization library components.  


\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespaceflow_1_1driver}{driver}}
\begin{DoxyCompactList}\small\item\em Synchronizations buffer with policies which produce sequencing ranges. \end{DoxyCompactList}\item 
 \mbox{\hyperlink{namespaceflow_1_1follower}{follower}}
\begin{DoxyCompactList}\small\item\em Synchronization buffers with sequencing range-\/dependent policies. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classflow_1_1_captor}{Captor}}
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1_captor_3_01_captor_t_00_01_no_lock_00_01_queue_monitor_t_01_4}{Captor$<$ Captor\+T, No\+Lock, Queue\+Monitor\+T $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} container constructor. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1_captor_3_01_captor_t_00_01_polling_lock_3_01_basic_lockable_t_01_4_00_01_queue_monitor_t_01_4}{Captor$<$ Captor\+T, Polling\+Lock$<$ Basic\+Lockable\+T $>$, Queue\+Monitor\+T $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} container constructor. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1_captor_interface}{Captor\+Interface}}
\begin{DoxyCompactList}\small\item\em C\+R\+T\+P-\/base which defines basic captor interface. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits}{Captor\+Traits}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01_captor_3_01_captor_t_00_01_lockable_t_00_01_queue_monitor_t_01_4_01_4}{Captor\+Traits$<$ Captor$<$ Captor\+T, Lockable\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01driver_1_1_batch_3_01_dispatch_t_00_01_lock_policy_t_00_01_contfc7418d386a7a1cb1fa7e6bb1299634a}{Captor\+Traits$<$ driver\+::\+Batch$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01driver_1_1_chunk_3_01_dispatch_t_00_01_lock_policy_t_00_01_contf25136d799b84e6e744301cf371fdfc2}{Captor\+Traits$<$ driver\+::\+Chunk$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01driver_1_1_next_3_01_dispatch_t_00_01_lock_policy_t_00_01_contacacf8f9584444cf22afe31e8b706b576}{Captor\+Traits$<$ driver\+::\+Next$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01driver_1_1_throttled_3_01_dispatch_t_00_01_lock_policy_t_00_01_a55b272e8914e815b1e61540d6e370f1}{Captor\+Traits$<$ driver\+::\+Throttled$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01_driver_3_01_policy_t_01_4_01_4}{Captor\+Traits$<$ Driver$<$ Policy\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01follower_1_1_any_before_3_01_dispatch_t_00_01_lock_policy_t_00_55050b2eb17fc5bc754f0ec7f3a869fd}{Captor\+Traits$<$ follower\+::\+Any\+Before$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01follower_1_1_before_3_01_dispatch_t_00_01_lock_policy_t_00_01_c62c65191d3908e10afd70708af893571}{Captor\+Traits$<$ follower\+::\+Before$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01follower_1_1_closest_before_3_01_dispatch_t_00_01_lock_policy_t8b834bc2517b16c76af22e1a13353500}{Captor\+Traits$<$ follower\+::\+Closest\+Before$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01follower_1_1_count_before_3_01_dispatch_t_00_01_lock_policy_t_0d08c28482191f4a9fdac77c50d53921d}{Captor\+Traits$<$ follower\+::\+Count\+Before$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01follower_1_1_latched_3_01_dispatch_t_00_01_lock_policy_t_00_01_7069ffe3c5f41ae454dc415b835f945a}{Captor\+Traits$<$ follower\+::\+Latched$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01follower_1_1_matched_stamp_3_01_dispatch_t_00_01_lock_policy_t_98530359aca39d952e431eb90b81d0f7}{Captor\+Traits$<$ follower\+::\+Matched\+Stamp$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01follower_1_1_ranged_3_01_dispatch_t_00_01_lock_policy_t_00_01_c08104af94995091b5ab7569e730f476c}{Captor\+Traits$<$ follower\+::\+Ranged$<$ Dispatch\+T, Lock\+Policy\+T, Container\+T, Queue\+Monitor\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_3_01_follower_3_01_policy_t_01_4_01_4}{Captor\+Traits$<$ Follower$<$ Policy\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Traits struct for captor types. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_captor_traits_from_dispatch}{Captor\+Traits\+From\+Dispatch}}
\begin{DoxyCompactList}\small\item\em Basic captor traits struct with common type information from data dispatch object. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_capture_range}{Capture\+Range}}
\begin{DoxyCompactList}\small\item\em Data capture/sequencing information. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_default_dispatch_queue_monitor}{Default\+Dispatch\+Queue\+Monitor}}
\begin{DoxyCompactList}\small\item\em Stand-\/in type used to replace queue monitor. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} data wrapper. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_dispatch_access}{Dispatch\+Access}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} access helper. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_dispatch_access_3_01_dispatch_3_01_stamp_t_00_01_value_t_01_4_01_4}{Dispatch\+Access$<$ Dispatch$<$ Stamp\+T, Value\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} access helper. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_dispatch_access_3_1_1std_1_1pair_3_01_stamp_t_00_01_value_t_01_4_01_4}{Dispatch\+Access$<$\+::std\+::pair$<$ Stamp\+T, Value\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} access helper. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1_dispatch_queue}{Dispatch\+Queue}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} queuing data structure. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_dispatch_traits}{Dispatch\+Traits}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} type traits struct. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_dispatch_traits_3_01_dispatch_3_01_stamp_t_00_01_value_t_01_4_01_4}{Dispatch\+Traits$<$ Dispatch$<$ Stamp\+T, Value\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} type traits struct. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_dispatch_traits_3_1_1std_1_1pair_3_01_stamp_t_00_01_value_t_01_4_01_4}{Dispatch\+Traits$<$\+::std\+::pair$<$ Stamp\+T, Value\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} type traits struct. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1_driver}{Driver}}
\begin{DoxyCompactList}\small\item\em C\+R\+T\+P-\/base for \mbox{\hyperlink{classflow_1_1_driver}{Driver}} input-\/capture policies. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_extraction_range}{Extraction\+Range}}
\begin{DoxyCompactList}\small\item\em Represents a range of elements. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1_follower}{Follower}}
\begin{DoxyCompactList}\small\item\em C\+R\+T\+P-\/base for \mbox{\hyperlink{classflow_1_1_follower}{Follower}} input-\/capture policies. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1integer__sequence}{integer\+\_\+sequence}}
\begin{DoxyCompactList}\small\item\em Represents a compile-\/time sequence of integers. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1is__capture__range}{is\+\_\+capture\+\_\+range}}
\begin{DoxyCompactList}\small\item\em Checks if object type is an instance of \mbox{\hyperlink{structflow_1_1_capture_range}{Capture\+Range}}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1is__capture__range_3_01_capture_range_3_01_stamp_t_01_4_01_4}{is\+\_\+capture\+\_\+range$<$ Capture\+Range$<$ Stamp\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Checks if object type is an instance of \mbox{\hyperlink{structflow_1_1_capture_range}{Capture\+Range}}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1is__driver}{is\+\_\+driver}}
\begin{DoxyCompactList}\small\item\em Checks if captor object derived from a \mbox{\hyperlink{classflow_1_1_driver}{Driver}} base. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1is__follower}{is\+\_\+follower}}
\begin{DoxyCompactList}\small\item\em Checks if captor object derived from a \mbox{\hyperlink{classflow_1_1_follower}{Follower}} base. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1is__no__lock}{is\+\_\+no\+\_\+lock}}
\begin{DoxyCompactList}\small\item\em Checks if {\ttfamily LockableT} is of type \mbox{\hyperlink{structflow_1_1_no_lock}{No\+Lock}}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1is__polling}{is\+\_\+polling}}
\begin{DoxyCompactList}\small\item\em Checks if captor is serviced by polling capture. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1is__polling__lock}{is\+\_\+polling\+\_\+lock}}
\begin{DoxyCompactList}\small\item\em Checks if {\ttfamily LockableT} is instance of \mbox{\hyperlink{structflow_1_1_polling_lock}{Polling\+Lock}}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1is__polling__lock_3_01_polling_lock_3_01_lockable_t_01_4_01_4}{is\+\_\+polling\+\_\+lock$<$ Polling\+Lock$<$ Lockable\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Checks if {\ttfamily LockableT} is instance of \mbox{\hyperlink{structflow_1_1_polling_lock}{Polling\+Lock}}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_no_capture}{No\+Capture}}
\begin{DoxyCompactList}\small\item\em Object used in place of output iterator as a placeholder with no data capture effects. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_no_lock}{No\+Lock}}
\begin{DoxyCompactList}\small\item\em Stand-\/in type used to signify that captors will be used in a single-\/threaded context. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1optional}{optional}}
\begin{DoxyCompactList}\small\item\em The class template std\+::optional manages an optional contained value, i.\+e. a value that may or may not be present. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_polling_lock}{Polling\+Lock}}
\begin{DoxyCompactList}\small\item\em Stand-\/in type used to signify that captors will be used in a threaded context, but will not wait for data. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_result}{Result}}
\begin{DoxyCompactList}\small\item\em Event synchronization result summary. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_sequence_stamp_type}{Sequence\+Stamp\+Type}}
\begin{DoxyCompactList}\small\item\em Resolves stamp type used by a captor. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_sequence_stamp_type_3_01_capture_range_3_01_stamp_t_01_4_01_4}{Sequence\+Stamp\+Type$<$ Capture\+Range$<$ Stamp\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Resolves stamp type used by a captor. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_stamp_traits}{Stamp\+Traits}}
\begin{DoxyCompactList}\small\item\em Helper struct used to specify stamp attributes. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structflow_1_1_stamp_traits_3_01std_1_1chrono_1_1time__point_3_01_clock_t_00_01_duration_t_01_4_01_4}{Stamp\+Traits$<$ std\+::chrono\+::time\+\_\+point$<$ Clock\+T, Duration\+T $>$ $>$}}
\begin{DoxyCompactList}\small\item\em Helper struct used to specify stamp attributes for $<$chrono$>$ time types. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classflow_1_1_synchronizer}{Synchronizer}}
\begin{DoxyCompactList}\small\item\em Provides facilities to synchronize data across several Captors. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceflow_ae5be95d6aaac2a27a1504e60657ad00d}\label{namespaceflow_ae5be95d6aaac2a27a1504e60657ad00d}} 
{\footnotesize template$<$typename DispatchT $>$ }\\using \mbox{\hyperlink{namespaceflow_ae5be95d6aaac2a27a1504e60657ad00d}{Default\+Container}} = std\+::deque$<$ DispatchT $>$
\begin{DoxyCompactList}\small\item\em Default dispatch container template. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename IntT , size\+\_\+t N$>$ }\\using \mbox{\hyperlink{namespaceflow_a44acfd29334c5a961b08887a82a22932}{make\+\_\+integer\+\_\+sequence}} = typename detail\+::make\+\_\+sequence$<$ IntT, N $>$\+::type
\begin{DoxyCompactList}\small\item\em Integer sequence where the integer type is {\ttfamily std\+::size\+\_\+t} \end{DoxyCompactList}\item 
{\footnotesize template$<$size\+\_\+t... Ns$>$ }\\using \mbox{\hyperlink{namespaceflow_a769177078022dbaf784d0700d6136c29}{index\+\_\+sequence}} = \mbox{\hyperlink{structflow_1_1integer__sequence}{integer\+\_\+sequence}}$<$ size\+\_\+t, Ns... $>$
\begin{DoxyCompactList}\small\item\em Integer sequence where the integer type is {\ttfamily size\+\_\+t} \end{DoxyCompactList}\item 
{\footnotesize template$<$size\+\_\+t N$>$ }\\using \mbox{\hyperlink{namespaceflow_a81b3555e96800ec11b6c29de82a492b4}{make\+\_\+index\+\_\+sequence}} = \mbox{\hyperlink{namespaceflow_a44acfd29334c5a961b08887a82a22932}{make\+\_\+integer\+\_\+sequence}}$<$ size\+\_\+t, N $>$
\begin{DoxyCompactList}\small\item\em Makes an integer sequence where the integer type is {\ttfamily size\+\_\+t} \end{DoxyCompactList}\item 
{\footnotesize template$<$class... T\+Pack$>$ }\\using \mbox{\hyperlink{namespaceflow_ae4e2e4c6e6b3fd8dfe4d3babc189f807}{index\+\_\+sequence\+\_\+for}} = \mbox{\hyperlink{namespaceflow_a44acfd29334c5a961b08887a82a22932}{make\+\_\+integer\+\_\+sequence}}$<$ size\+\_\+t, sizeof...(T\+Pack)$>$
\begin{DoxyCompactList}\small\item\em Makes an index sequence type with elements for each type in {\ttfamily T...} \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}} \+: int \{ \newline
\mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9ac0cc02c3b3d55abb7bfb49ddbb4866c8}{State\+::\+R\+E\+T\+RY}}, 
\mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a6eed4968877959d0209d9b75fdd16b52}{State\+::\+P\+R\+I\+M\+ED}}, 
\mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a8d12a2ca7e5a64036d7251a3eda51a38}{State\+::\+A\+B\+O\+RT}}, 
\mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a070a0fb40f6c308ab544b227660aadff}{State\+::\+T\+I\+M\+E\+O\+UT}}, 
\newline
\mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a5fb9cb06b1db824c6527795c8d73925d}{State\+::\+E\+R\+R\+O\+R\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+L\+O\+W\+E\+R\+\_\+\+B\+O\+U\+N\+D\+\_\+\+E\+X\+C\+E\+E\+D\+ED}}, 
\mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a553bb3189571a5b09c1d53c315abd8f8}{State\+::\+S\+K\+I\+P\+\_\+\+F\+R\+A\+M\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+P\+R\+E\+C\+O\+N\+D\+I\+T\+I\+ON}}, 
\mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a63b87258ef5b5f3ccdfd68f9e673d66d}{State\+::\+\_\+\+N\+\_\+\+S\+T\+A\+T\+ES}}
 \}
\begin{DoxyCompactList}\small\item\em Evaluated Captor state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespaceflow_a02c72a25c49711b0983b4b6f6c1f5d7d}\label{namespaceflow_a02c72a25c49711b0983b4b6f6c1f5d7d}} 
{\footnotesize template$<$typename... Other\+Ts$>$ }\\constexpr bool {\bfseries operator==} (const \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}} lhs, const std\+::tuple$<$ \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}}, Other\+Ts... $>$ \&rhs)
\item 
\mbox{\Hypertarget{namespaceflow_a64d98f45c52bf4a40e1e29a055776882}\label{namespaceflow_a64d98f45c52bf4a40e1e29a055776882}} 
{\footnotesize template$<$typename... Other\+Ts$>$ }\\constexpr bool {\bfseries operator!=} (const \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}} lhs, const std\+::tuple$<$ \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}}, Other\+Ts... $>$ \&rhs)
\item 
\mbox{\Hypertarget{namespaceflow_a3842b5e8cd96a88a9b72471da6297bee}\label{namespaceflow_a3842b5e8cd96a88a9b72471da6297bee}} 
{\footnotesize template$<$typename... Other\+Ts$>$ }\\constexpr bool {\bfseries operator==} (const std\+::tuple$<$ \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}}, Other\+Ts... $>$ \&lhs, const \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}} rhs)
\item 
\mbox{\Hypertarget{namespaceflow_ad41dcb83f942760c61de41f96bba6322}\label{namespaceflow_ad41dcb83f942760c61de41f96bba6322}} 
{\footnotesize template$<$typename... Other\+Ts$>$ }\\constexpr bool {\bfseries operator!=} (const std\+::tuple$<$ \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}}, Other\+Ts... $>$ \&lhs, const \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}} rhs)
\item 
std\+::ostream \& \mbox{\hyperlink{namespaceflow_add94bf5b887f5f969dd2988fdf0673d9}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}} state)
\begin{DoxyCompactList}\small\item\em Output stream overload for {\ttfamily State} codes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceflow_a7e74f2c2aa617c702eb0b184658b3e2e}\label{namespaceflow_a7e74f2c2aa617c702eb0b184658b3e2e}} 
{\footnotesize template$<$typename DispatchT $>$ }\\constexpr auto \mbox{\hyperlink{namespaceflow_a7e74f2c2aa617c702eb0b184658b3e2e}{get\+\_\+stamp}} (DispatchT \&\&dispatch)
\begin{DoxyCompactList}\small\item\em Accesses \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} stamp through appropriate accessors. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespaceflow_ae6b46b0890787880f9cb14596a3c3be5}\label{namespaceflow_ae6b46b0890787880f9cb14596a3c3be5}} 
{\footnotesize template$<$typename DispatchT $>$ }\\constexpr auto \mbox{\hyperlink{namespaceflow_ae6b46b0890787880f9cb14596a3c3be5}{get\+\_\+value}} (DispatchT \&\&dispatch)
\begin{DoxyCompactList}\small\item\em Accesses \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}} value through appropriate accessors. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename StampT , typename ValueT $>$ }\\std\+::ostream \& \mbox{\hyperlink{namespaceflow_ae7e587a04ccd87fa5982d609473c6f96}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}}$<$ StampT, ValueT $>$ \&dispatch)
\begin{DoxyCompactList}\small\item\em Output stream overload for {\ttfamily \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename StampT $>$ }\\std\+::ostream \& \mbox{\hyperlink{namespaceflow_a8423b9d75e853c9c36724474ba20d63a}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{structflow_1_1_capture_range}{Capture\+Range}}$<$ StampT $>$ \&range)
\begin{DoxyCompactList}\small\item\em Output stream overload for {\ttfamily \mbox{\hyperlink{structflow_1_1_capture_range}{Capture\+Range}}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename StampT $>$ }\\std\+::ostream \& \mbox{\hyperlink{namespaceflow_a7ca1e3a34fdc4e532e45869d9141c53a}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{structflow_1_1_result}{Result}}$<$ StampT $>$ \&result)
\begin{DoxyCompactList}\small\item\em Output stream overload for {\ttfamily \mbox{\hyperlink{structflow_1_1_result}{Result}}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Unary\+InvocableT , typename Arg\+TupleT $>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespaceflow_a576ffe4655756f441e6b680ae6c584ef}{apply}} (Unary\+InvocableT \&\&fn, Arg\+TupleT \&\&targs)
\item 
{\footnotesize template$<$typename ReturnT , typename Unary\+InvocableT , typename Arg\+TupleT $>$ }\\constexpr std\+::enable\+\_\+if$<$ std\+::is\+\_\+void$<$ ReturnT $>$\+::value $>$\+::type \mbox{\hyperlink{namespaceflow_addfb557e2933e92a2192c0de4d6b4621}{apply}} (Unary\+InvocableT \&\&fn, Arg\+TupleT \&\&targs)
\begin{DoxyCompactList}\small\item\em Calls function with with tuple (e.\+g {\ttfamily std\+::tuple}) as argument list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename N\+Ary\+InvocableT , typename... Arg\+Tuples$>$ }\\constexpr void \mbox{\hyperlink{namespaceflow_af637729bd4e582460174c671dc619000}{apply\+\_\+every}} (N\+Ary\+InvocableT \&\&fn, Arg\+Tuples \&\&... targs)
\begin{DoxyCompactList}\small\item\em Calls a N-\/ary function on each element of N tuples (e.\+g {\ttfamily std\+::tuple}) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename N\+Ary\+InvocableT , typename... Arg\+Tuples$>$ }\\constexpr auto \mbox{\hyperlink{namespaceflow_aec52d21de83de43502e0e26915388933}{apply\+\_\+every\+\_\+r}} (N\+Ary\+InvocableT \&\&fn, Arg\+Tuples \&\&... targs)
\begin{DoxyCompactList}\small\item\em Calls a N-\/ary function with a returned value on each element of N tuples (e.\+g {\ttfamily std\+::tuple}) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Unary\+Invocable\+TupleT , typename Arg\+TupleT $>$ }\\constexpr void \mbox{\hyperlink{namespaceflow_af332d2067ac2938609786e4bb3ad8b5e}{apply\+\_\+each}} (Unary\+Invocable\+TupleT \&\&fns, Arg\+TupleT \&\&targs)
\begin{DoxyCompactList}\small\item\em Calls a unique function on each element of a tuple (e.\+g {\ttfamily std\+::tuple}) \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Flow input synchronization library components. 

Implements the C++17 utility {\ttfamily std\+::integer\+\_\+sequence} and related compile-\/time utility objects.

Defines a utility similar to {\ttfamily std\+::apply} (C++14)

\begin{DoxyCopyright}{Copyright}
2020-\/present Fetch Robotics Inc. 
\end{DoxyCopyright}
\begin{DoxyAuthor}{Author}
Brian Cairl
\end{DoxyAuthor}
\begin{DoxyCopyright}{Copyright}
2020-\/present Fetch Robotics Inc. 
\end{DoxyCopyright}
\begin{DoxyAuthor}{Author}
Levon Avagyan, Brian Cairl
\end{DoxyAuthor}
\begin{DoxyCopyright}{Copyright}
2020-\/present Fetch Robotics Inc. 
\end{DoxyCopyright}
\begin{DoxyAuthor}{Author}
Brian Cairl, Derek King
\end{DoxyAuthor}
\begin{DoxyCopyright}{Copyright}
2020-\/present Fetch Robotics Inc. 
\end{DoxyCopyright}
\begin{DoxyAuthor}{Author}
Brian Cairl
\end{DoxyAuthor}
\begin{DoxyWarning}{Warning}
I\+M\+P\+L\+E\+M\+E\+N\+T\+A\+T\+I\+ON O\+N\+LY\+: T\+H\+IS F\+I\+LE S\+H\+O\+U\+LD N\+E\+V\+ER BE I\+N\+C\+L\+U\+D\+ED D\+I\+R\+E\+C\+T\+L\+Y!
\end{DoxyWarning}
\begin{DoxyCopyright}{Copyright}
2020-\/present Fetch Robotics Inc. 
\end{DoxyCopyright}
\begin{DoxyAuthor}{Author}
Levon Avagyan, Brian Cairl
\end{DoxyAuthor}
\begin{DoxyWarning}{Warning}
I\+M\+P\+L\+E\+M\+E\+N\+T\+A\+T\+I\+ON O\+N\+LY\+: T\+H\+IS F\+I\+LE S\+H\+O\+U\+LD N\+E\+V\+ER BE I\+N\+C\+L\+U\+D\+ED D\+I\+R\+E\+C\+T\+L\+Y!
\end{DoxyWarning}
\begin{DoxyCopyright}{Copyright}
2020-\/present Fetch Robotics Inc. 
\end{DoxyCopyright}
\begin{DoxyAuthor}{Author}
Brian Cairl, Derek King
\end{DoxyAuthor}
\begin{DoxyWarning}{Warning}
I\+M\+P\+L\+E\+M\+E\+N\+T\+A\+T\+I\+ON O\+N\+LY\+: T\+H\+IS F\+I\+LE S\+H\+O\+U\+LD N\+E\+V\+ER BE I\+N\+C\+L\+U\+D\+ED D\+I\+R\+E\+C\+T\+L\+Y!
\end{DoxyWarning}
\begin{DoxyCopyright}{Copyright}
2020-\/present Fetch Robotics Inc. 
\end{DoxyCopyright}
\begin{DoxyAuthor}{Author}
Brian Cairl
\end{DoxyAuthor}
\begin{DoxyVerb}   For reference, see
   <a href="http://en.cppreference.com/w/cpp/utility/apply">here</a>
\end{DoxyVerb}


\begin{DoxyCopyright}{Copyright}
2020-\/present Fetch Robotics Inc. 
\end{DoxyCopyright}
\begin{DoxyAuthor}{Author}
Brian Cairl
\end{DoxyAuthor}
For reference on how this works, see $<$a href="\href{https://blog.galowicz.de/2016/06/24/integer_sequences_at_compile_time/}{\texttt{ https\+://blog.\+galowicz.\+de/2016/06/24/integer\+\_\+sequences\+\_\+at\+\_\+compile\+\_\+time/}}. 

\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{namespaceflow_a769177078022dbaf784d0700d6136c29}\label{namespaceflow_a769177078022dbaf784d0700d6136c29}} 
\index{flow@{flow}!index\_sequence@{index\_sequence}}
\index{index\_sequence@{index\_sequence}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{index\_sequence}{index\_sequence}}
{\footnotesize\ttfamily template$<$size\+\_\+t... Ns$>$ \\
using \mbox{\hyperlink{namespaceflow_a769177078022dbaf784d0700d6136c29}{flow\+::index\+\_\+sequence}} = typedef \mbox{\hyperlink{structflow_1_1integer__sequence}{integer\+\_\+sequence}}$<$size\+\_\+t, Ns...$>$}



Integer sequence where the integer type is {\ttfamily size\+\_\+t} 


\begin{DoxyTemplParams}{Template Parameters}
{\em Ns...} & pack of integer values of type {\ttfamily std\+::size\+\_\+t} \\
\hline
\end{DoxyTemplParams}
\mbox{\Hypertarget{namespaceflow_ae4e2e4c6e6b3fd8dfe4d3babc189f807}\label{namespaceflow_ae4e2e4c6e6b3fd8dfe4d3babc189f807}} 
\index{flow@{flow}!index\_sequence\_for@{index\_sequence\_for}}
\index{index\_sequence\_for@{index\_sequence\_for}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{index\_sequence\_for}{index\_sequence\_for}}
{\footnotesize\ttfamily template$<$class... T\+Pack$>$ \\
using \mbox{\hyperlink{namespaceflow_ae4e2e4c6e6b3fd8dfe4d3babc189f807}{flow\+::index\+\_\+sequence\+\_\+for}} = typedef \mbox{\hyperlink{namespaceflow_a44acfd29334c5a961b08887a82a22932}{make\+\_\+integer\+\_\+sequence}}$<$size\+\_\+t, sizeof...(T\+Pack)$>$}



Makes an index sequence type with elements for each type in {\ttfamily T...} 


\begin{DoxyParams}{Parameters}
{\em T\+Pack...} & pack of arbitrary types \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceflow_a81b3555e96800ec11b6c29de82a492b4}\label{namespaceflow_a81b3555e96800ec11b6c29de82a492b4}} 
\index{flow@{flow}!make\_index\_sequence@{make\_index\_sequence}}
\index{make\_index\_sequence@{make\_index\_sequence}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{make\_index\_sequence}{make\_index\_sequence}}
{\footnotesize\ttfamily template$<$size\+\_\+t N$>$ \\
using \mbox{\hyperlink{namespaceflow_a81b3555e96800ec11b6c29de82a492b4}{flow\+::make\+\_\+index\+\_\+sequence}} = typedef \mbox{\hyperlink{namespaceflow_a44acfd29334c5a961b08887a82a22932}{make\+\_\+integer\+\_\+sequence}}$<$size\+\_\+t, N$>$}



Makes an integer sequence where the integer type is {\ttfamily size\+\_\+t} 


\begin{DoxyTemplParams}{Template Parameters}
{\em N} & number of indices in sequence, i.\+e. {\ttfamily \mbox{[}0, 1, ..., N-\/2, N-\/1\mbox{]}} \\
\hline
\end{DoxyTemplParams}
\mbox{\Hypertarget{namespaceflow_a44acfd29334c5a961b08887a82a22932}\label{namespaceflow_a44acfd29334c5a961b08887a82a22932}} 
\index{flow@{flow}!make\_integer\_sequence@{make\_integer\_sequence}}
\index{make\_integer\_sequence@{make\_integer\_sequence}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{make\_integer\_sequence}{make\_integer\_sequence}}
{\footnotesize\ttfamily template$<$typename IntT , size\+\_\+t N$>$ \\
using \mbox{\hyperlink{namespaceflow_a44acfd29334c5a961b08887a82a22932}{flow\+::make\+\_\+integer\+\_\+sequence}} = typedef typename detail\+::make\+\_\+sequence$<$IntT, N$>$\+::type}



Integer sequence where the integer type is {\ttfamily std\+::size\+\_\+t} 


\begin{DoxyTemplParams}{Template Parameters}
{\em IntT} & integer element type \\
\hline
{\em N} & number of indices in sequence, i.\+e. {\ttfamily \mbox{[}0, 1, ..., N-\/2, N-\/1\mbox{]}} \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}\label{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}} 
\index{flow@{flow}!State@{State}}
\index{State@{State}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{State}{State}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{flow\+::\+State}} \+: int\hspace{0.3cm}{\ttfamily [strong]}}



Evaluated \mbox{\hyperlink{classflow_1_1_captor}{Captor}} state. 

These are used by captors to direct internal data capture behavior \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{RETRY@{RETRY}!flow@{flow}}\index{flow@{flow}!RETRY@{RETRY}}}\mbox{\Hypertarget{namespaceflow_adefe9726e597eb50c46f0f6a202018e9ac0cc02c3b3d55abb7bfb49ddbb4866c8}\label{namespaceflow_adefe9726e597eb50c46f0f6a202018e9ac0cc02c3b3d55abb7bfb49ddbb4866c8}} 
R\+E\+T\+RY&\mbox{\hyperlink{classflow_1_1_captor}{Captor}} should continue waiting for data after prime attempt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PRIMED@{PRIMED}!flow@{flow}}\index{flow@{flow}!PRIMED@{PRIMED}}}\mbox{\Hypertarget{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a6eed4968877959d0209d9b75fdd16b52}\label{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a6eed4968877959d0209d9b75fdd16b52}} 
P\+R\+I\+M\+ED&\mbox{\hyperlink{classflow_1_1_captor}{Captor}} has captured data and its ready. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ABORT@{ABORT}!flow@{flow}}\index{flow@{flow}!ABORT@{ABORT}}}\mbox{\Hypertarget{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a8d12a2ca7e5a64036d7251a3eda51a38}\label{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a8d12a2ca7e5a64036d7251a3eda51a38}} 
A\+B\+O\+RT&\mbox{\hyperlink{classflow_1_1_captor}{Captor}} has requested to abort current capture attempt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{TIMEOUT@{TIMEOUT}!flow@{flow}}\index{flow@{flow}!TIMEOUT@{TIMEOUT}}}\mbox{\Hypertarget{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a070a0fb40f6c308ab544b227660aadff}\label{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a070a0fb40f6c308ab544b227660aadff}} 
T\+I\+M\+E\+O\+UT&\mbox{\hyperlink{classflow_1_1_captor}{Captor}} has hit a data-\/wait timeout. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ERROR\_DRIVER\_LOWER\_BOUND\_EXCEEDED@{ERROR\_DRIVER\_LOWER\_BOUND\_EXCEEDED}!flow@{flow}}\index{flow@{flow}!ERROR\_DRIVER\_LOWER\_BOUND\_EXCEEDED@{ERROR\_DRIVER\_LOWER\_BOUND\_EXCEEDED}}}\mbox{\Hypertarget{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a5fb9cb06b1db824c6527795c8d73925d}\label{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a5fb9cb06b1db824c6527795c8d73925d}} 
E\+R\+R\+O\+R\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+L\+O\+W\+E\+R\+\_\+\+B\+O\+U\+N\+D\+\_\+\+E\+X\+C\+E\+E\+D\+ED&Error code used to indicate that driving violated external lower bound. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SKIP\_FRAME\_QUEUE\_PRECONDITION@{SKIP\_FRAME\_QUEUE\_PRECONDITION}!flow@{flow}}\index{flow@{flow}!SKIP\_FRAME\_QUEUE\_PRECONDITION@{SKIP\_FRAME\_QUEUE\_PRECONDITION}}}\mbox{\Hypertarget{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a553bb3189571a5b09c1d53c315abd8f8}\label{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a553bb3189571a5b09c1d53c315abd8f8}} 
S\+K\+I\+P\+\_\+\+F\+R\+A\+M\+E\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+P\+R\+E\+C\+O\+N\+D\+I\+T\+I\+ON&Code use to indicate that the current sync frame is to be skipped, namely when when a queue monitor object is used to precondition capture \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{\_N\_STATES@{\_N\_STATES}!flow@{flow}}\index{flow@{flow}!\_N\_STATES@{\_N\_STATES}}}\mbox{\Hypertarget{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a63b87258ef5b5f3ccdfd68f9e673d66d}\label{namespaceflow_adefe9726e597eb50c46f0f6a202018e9a63b87258ef5b5f3ccdfd68f9e673d66d}} 
\+\_\+\+N\+\_\+\+S\+T\+A\+T\+ES&Total number of captor states. \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespaceflow_a576ffe4655756f441e6b680ae6c584ef}\label{namespaceflow_a576ffe4655756f441e6b680ae6c584ef}} 
\index{flow@{flow}!apply@{apply}}
\index{apply@{apply}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{apply()}{apply()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Unary\+InvocableT , typename Arg\+TupleT $>$ \\
constexpr decltype(auto) flow\+::apply (\begin{DoxyParamCaption}\item[{Unary\+InvocableT \&\&}]{fn,  }\item[{Arg\+TupleT \&\&}]{targs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}





\begin{DoxyReturn}{Returns}
return value of {\ttfamily fn} when passed arguments from {\ttfamily targs} 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Participates in overload resolution when {\ttfamily ReturnT} is non-\/{\ttfamily void} 
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
return value of {\ttfamily fn} when passed arguments from {\ttfamily targs} 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Participates in overload resolution when {\ttfamily ReturnT} is non-\/{\ttfamily void} 
\end{DoxyNote}
\mbox{\Hypertarget{namespaceflow_addfb557e2933e92a2192c0de4d6b4621}\label{namespaceflow_addfb557e2933e92a2192c0de4d6b4621}} 
\index{flow@{flow}!apply@{apply}}
\index{apply@{apply}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{apply()}{apply()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename ReturnT , typename Unary\+InvocableT , typename Arg\+TupleT $>$ \\
constexpr std\+::enable\+\_\+if$<$std\+::is\+\_\+void$<$ReturnT$>$\+::value$>$\+::type flow\+::apply (\begin{DoxyParamCaption}\item[{Unary\+InvocableT \&\&}]{fn,  }\item[{Arg\+TupleT \&\&}]{targs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}



Calls function with with tuple (e.\+g {\ttfamily std\+::tuple}) as argument list. 


\begin{DoxyTemplParams}{Template Parameters}
{\em ReturnT} & function return type \\
\hline
{\em Unary\+InvocableT} & (deduced) invocable type\+:
\begin{DoxyItemize}
\item function pointer
\item functor object with {\ttfamily Object\+::operator()}
\item lambda function expression 
\end{DoxyItemize}\\
\hline
{\em TupleT} & (deduced) tuple-\/like type with element types order according to function argument list\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em fn} & function pointer or functor object type \\
\hline
{\em targs} & tuple with arguments to pass to {\ttfamily f} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceflow_af332d2067ac2938609786e4bb3ad8b5e}\label{namespaceflow_af332d2067ac2938609786e4bb3ad8b5e}} 
\index{flow@{flow}!apply\_each@{apply\_each}}
\index{apply\_each@{apply\_each}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{apply\_each()}{apply\_each()}}
{\footnotesize\ttfamily template$<$typename Unary\+Invocable\+TupleT , typename Arg\+TupleT $>$ \\
constexpr void flow\+::apply\+\_\+each (\begin{DoxyParamCaption}\item[{Unary\+Invocable\+TupleT \&\&}]{fns,  }\item[{Arg\+TupleT \&\&}]{targs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}



Calls a unique function on each element of a tuple (e.\+g {\ttfamily std\+::tuple}) 


\begin{DoxyTemplParams}{Template Parameters}
{\em Unary\+Invocable\+TupleT} & (deduced) binary invocable type\+:
\begin{DoxyItemize}
\item function pointer
\item functor object with {\ttfamily Object\+::operator()}
\item lambda function expression 
\end{DoxyItemize}\\
\hline
{\em Arg\+TupleT} & (deduced) tuple-\/like type with element types order according to function argument list\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em fns} & tuple of function pointers or functor objects \\
\hline
{\em targs} & tuple with arguments to pass to {\ttfamily f} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceflow_af637729bd4e582460174c671dc619000}\label{namespaceflow_af637729bd4e582460174c671dc619000}} 
\index{flow@{flow}!apply\_every@{apply\_every}}
\index{apply\_every@{apply\_every}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{apply\_every()}{apply\_every()}}
{\footnotesize\ttfamily template$<$typename N\+Ary\+InvocableT , typename... Arg\+Tuples$>$ \\
constexpr void flow\+::apply\+\_\+every (\begin{DoxyParamCaption}\item[{N\+Ary\+InvocableT \&\&}]{fn,  }\item[{Arg\+Tuples \&\&...}]{targs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}



Calls a N-\/ary function on each element of N tuples (e.\+g {\ttfamily std\+::tuple}) 


\begin{DoxyTemplParams}{Template Parameters}
{\em N\+Ary\+InvocableT} & (deduced) n-\/ary invocable type\+:
\begin{DoxyItemize}
\item function pointer
\item functor object with {\ttfamily Object\+::operator()}
\item lambda function expression 
\end{DoxyItemize}\\
\hline
{\em Arg\+Tuples} & (deduced) tuple-\/like type with element types order according to function argument list\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em fn} & function pointer or functor object \\
\hline
{\em targs} & tuple with arguments to pass to {\ttfamily f} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceflow_aec52d21de83de43502e0e26915388933}\label{namespaceflow_aec52d21de83de43502e0e26915388933}} 
\index{flow@{flow}!apply\_every\_r@{apply\_every\_r}}
\index{apply\_every\_r@{apply\_every\_r}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{apply\_every\_r()}{apply\_every\_r()}}
{\footnotesize\ttfamily template$<$typename N\+Ary\+InvocableT , typename... Arg\+Tuples$>$ \\
constexpr auto flow\+::apply\+\_\+every\+\_\+r (\begin{DoxyParamCaption}\item[{N\+Ary\+InvocableT \&\&}]{fn,  }\item[{Arg\+Tuples \&\&...}]{targs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}



Calls a N-\/ary function with a returned value on each element of N tuples (e.\+g {\ttfamily std\+::tuple}) 


\begin{DoxyTemplParams}{Template Parameters}
{\em N\+Ary\+InvocableT} & (deduced) n-\/ary invocable type\+:
\begin{DoxyItemize}
\item function pointer
\item functor object with {\ttfamily Object\+::operator()}
\item lambda function expression 
\end{DoxyItemize}\\
\hline
{\em Arg\+Tuples} & (deduced) tuple-\/like type with element types order according to function argument list\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em fn} & function pointer or functor object \\
\hline
{\em targs} & tuple with arguments to pass to {\ttfamily f}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
tuple of return values 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceflow_a8423b9d75e853c9c36724474ba20d63a}\label{namespaceflow_a8423b9d75e853c9c36724474ba20d63a}} 
\index{flow@{flow}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename StampT $>$ \\
std\+::ostream\& flow\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{structflow_1_1_capture_range}{Capture\+Range}}$<$ StampT $>$ \&}]{range }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Output stream overload for {\ttfamily \mbox{\hyperlink{structflow_1_1_capture_range}{Capture\+Range}}} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em os} & output stream \\
\hline
 & {\em range} & capture stamp range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
os 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceflow_ae7e587a04ccd87fa5982d609473c6f96}\label{namespaceflow_ae7e587a04ccd87fa5982d609473c6f96}} 
\index{flow@{flow}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename StampT , typename ValueT $>$ \\
std\+::ostream\& flow\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}}$<$ StampT, ValueT $>$ \&}]{dispatch }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Output stream overload for {\ttfamily \mbox{\hyperlink{classflow_1_1_dispatch}{Dispatch}}} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em os} & output stream \\
\hline
 & {\em dispatch} & dispatch object\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
os 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceflow_a7ca1e3a34fdc4e532e45869d9141c53a}\label{namespaceflow_a7ca1e3a34fdc4e532e45869d9141c53a}} 
\index{flow@{flow}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename StampT $>$ \\
std\+::ostream\& flow\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{structflow_1_1_result}{Result}}$<$ StampT $>$ \&}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Output stream overload for {\ttfamily \mbox{\hyperlink{structflow_1_1_result}{Result}}} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em os} & output stream \\
\hline
 & {\em result} & \mbox{\hyperlink{classflow_1_1_synchronizer}{Synchronizer}} result object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
os 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceflow_add94bf5b887f5f969dd2988fdf0673d9}\label{namespaceflow_add94bf5b887f5f969dd2988fdf0673d9}} 
\index{flow@{flow}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!flow@{flow}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily std\+::ostream\& flow\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{namespaceflow_adefe9726e597eb50c46f0f6a202018e9}{State}}}]{state }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Output stream overload for {\ttfamily State} codes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em os} & output stream \\
\hline
 & {\em state} & state code\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
os 
\end{DoxyReturn}
